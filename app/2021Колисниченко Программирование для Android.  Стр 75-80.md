## 3.5. Разрешения Аndrоid-приложений
Существуют два способа определения разрешений: при запуске приложения и во время его выполнения. При запуске разрешения выполняются так, как бьшо показано ранее, - через файл манифеста:
```xml
<manifest xmlns:android="http://schernas.android.com/apk/res/android" 
package="com.example.snazzyapp"> 
<uses-permission android:name="android.peпnission.SEND_SMS"/> 
<application ... > 
</application> 
</manifest> 
```
В Android 6 (API 23) появился еще один способ определения разрешений- во время выполнения приложения, или «на лету».
>**ВНИМАНИЕ!**
> Все описанное в этом разделе далее верно только для API 23, и если у вас устройство или целевой API SDK приложения 22 или ниже, система попросит пользователя при установке или обновлении приложения предоставить все опасные разрешения.

Прежде всего нужно проверить, есть ли у приложения нужное ему разрешение. Эrо делается с помощью метода *contextCompat.checkSelfPeпnission().* Проверим, есть ли у приложения разрешение на запись события в календарь:
```java 
// Считаем, что активность thisActivity является текущей 
int permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR);
```

Если у приложения есть нужное разрешение, метод возвращает *PackageManager. PERМISSION_GRANTED,* если же разрешения нет, возвращается значение *PackageManager. PERМISSION DENIED.*

Для запроса разрешений используется метод *requestPermissions():*
```java
ActivityCompat.requestPermissions(thisActivity, 
	new String[] {Manifest.perrnission.READ_CONTACTS},
	МY_PERМISSIONS_REQUEST_READ_CONTACТS);
```
Здесь *МУ_PERМISSIONS_REQUEST_READ_CONTACTS* - определенная приложением константа.
**Далее приведен более полный код запроса разрешений:**
```java
// Здесь thisActivity является текущей 
// Проверяем, есть ли у приложения нужные разрешения (READ_CONTACТS) 
if (CoпtextCompat.checkSelfPerrnission(thisActivity, Manifest.perrnission.READ_CONТACТS) != PackageManager.PERМISSION_GRANТED) { 
// Если разрешений нет, выводим пользователю пояснение, что 
// нам нужно. Определить, нужно ли пояснение, можно с помощью 
// метода shouldShowRequestPerrnissionRationale 
		if (ActivityCompat.shouldShowRequestPerrnissionRationale(thisActivity,  Manifest.perrnission.READ_CONTACTS)) { 
	// Показываем объяснение асинхронно, не нужно блокировать 
	// весь поток в ожидании ответа пользователя
	} else {
	// Объяснение не нужно, можем запросить разрешение 
		ActivityCompat.requestPerrnissions(thisActivity, new String[]){Manifest.permission.READ_CONTACТS}, МY_PERМISSIONS_REQUEST_READ_CONТACTS);
	}
}
```
**После того как мы запросили разрешения, нужно определить, бьmи ли они нам предоставлены. Обработать ответ позволяет следующий код:**
```java
@Override 
puЬlic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) { 
	switch (requestCode) { 
		case МY_PERМISSIONS_REQUEST_READ_CONTACТS: {
			// Если запрос отменен, результирующие массивы будут пусты 
			if (grantResults.length > О && grantResults[0] == PackageManager.PERМISSION_GRANTED) {
			// разрешения предоставлены, можно сделать то, 
			// что мы собирались
			} else {
			// разрешения не предоставлены, нужно отключить функционал, 
			// требующий разрешений
			}
			return;
		}
	}
}	
```
**В качестве дополнительного материала рекомендую ознакомиться со следующими документами:**
- http://developer.android.com/training/permissions/requesting.html - запрос разрешений;
- http://developer.android.com/training/permissions/best-practices.html - лучшая практика;
- http://developer.android.com/guide/topics/security/permissions.html#normal-dangerous - обычные и опасные разрешения.
# Глава 4. Интерфейс пользователя
## 4.1. Разметка интерфейса
### 4.1.1. Редактор разметки
Графический интерфейс пользователя формируется с помощью объектов: *View* (представление) - класс *android.view.View* и *ViewGroup* (группа представлений) ­   класс *android.view.ViewGroup.* Класс *ViewGroup* является дочерним классом для *View.*
Класс *View* - основа для подклассов, которые называются виджетами и представляют собой элементы пользовательского интерфейса: текстовые поля, кнопки ит. п.
Каждый объект *ViewGroup* - это контейнер, содержащий и упорядочивающий дочерние объекты *View.* Контейнерами являются такие элементы, как *RelativeLayout, LinearLayout, GridLayout, ConstraintLayout* И ряд других.
Разметка интерфейса пользователя - это процесс размещения элементов интерфейса (виджетов) в конкретном окне приложения (для конкретной деятельности). 
Разметку можно выполнять двумя способами. Первый заключается в редактировании ХМL-файла окна приложения. Для главного окна приложения это файл *res\layout\main.xml.* Этот способ по началу вам покажется более «суровым». Начинающим программистам больше понравится второй способ - графический. Android Studio предлагает очень удобный редактор разметки интерфейса пользователя (рис. 4.1 ).
> **ПРИМЕЧАНИЕ** 
> Если вы программировали на MS Visual Studio, где также можно создавать приложения для Android, то наверняка заметили, что визуальный редактор Visual Studio все же удобнее редактора разметки Android Studio. Хотя, возможно, это дело привычки.

Проблем с использованием визуального редактора, полагаю, у вас не возникнет, поэтому далее мы будем рассматривать разметку интерфейса пользователя путем редактирования ХМL-файла. На практике же вы можете использовать тот способ, который вам больше нравится.

![[Pasted image 20230207124651.png]]
*Рис.4.1. Графический редактор разметки интерфейса пользователя*

Итак, каждый элемент файла разметки является объектом класса *View* или класса *ViewGroup.* Если представить все элементы интерфейса пользователя в виде иерархии, то объекты класса *ViewGroup* будут родительскими объектами, а *View* - дочерними для них. Иерархия созданного интерфейса отображается в области **Component Tree** редактора интерфейса. На рис. 4.2 видно, что добавлена разметка *ConstraintLayout* и одна надпись. При этом разметка (компонент *ConstaintLayout*) принадлежит к классу *ViewGroup,* а надпись - к классу *View.*

Рассмотрим файл разметки (*res\layout\activity_main.xml*) проекта с двумя кнопками: **Start и Stop** (листинг 4.1). На этот раз будет задействована линейная (горизонтальная или вертикальная) разметка.

![[Pasted image 20230207124722.png]]
*Рис.4.2. Иерархия созданных объектов*
```xml
<?xml version="l.0" encoding="utf-B"?XLinearLayout 
xmlns:android="http://schemas.android.com/apk/res/android" 
android:orientation="vertical" android:layout_width="fill_parent" 
android:layout_height="fill_parent" android:weightSum="l"> <Button 
android:layout_width="wrap_content" 
android:layout_height="wrap_content" android:text="Cтapт" 
android:id="@+id/start" /> <Button 
android:layout_width="wrap_content" 
android:layout_height="wrap_content" android:text="Cтoп" 
android:id="@+id/button" /></LinearLayout> 
```

> **ПРИМЕЧАНИЕ**
> При указании надписей кнопок и других элементов рекомендуется использовать строки ресурсов, а не конкретные строковые значения. Для этого следует в файле *res\values\strings.xml* создать соответствующие строковые значения, а затем задать их в качестве значения атрибута *text.* Однако в листинге 4.1 я прописал обычные строковые значения - чтобы не приводить еще и листинг файла *strings.xml.*

В каждом файле разметки должен быть только один корневой элемент. В нашем случае таким элементом является *LinearLayout* (линейная разметка). После определения корневого элемента вы можете добавить в него дополнительные объекты разметки или виджеты в качестве дочерних элементов.

Рассмотрим атрибуты элемента LinearLayout:
- *xmlns:android* - объявление пространства имен Android. Это стандартный атрибут и стандартное значение для Аndrоid-приложения;
- *android:layout_width* - ширина объекта *View* или *ViewGroup.* В нашем случае объект занимает весь экран, поэтому используется значение *fill_parent;*
- *android:layout_height* - высота объекта;
- *android:text* - текст, который будет отображен на кнопке.

У каждого объекта *View* или *ViewGroup* свой набор атрибутов. С ними мы познакомимся чуть позже - когда будем рассматривать базовые виджеты.

Установить атрибуты объектов можно как с помощью файла разметки, так и в Jаvа-коде. В большинстве случаев имя атрибута XML соответствует названию метода в классе Java. 
Например, для установки атрибута *android:height* (задает высоту объекта) используется метод *setHeight(int),* для установки атрибута *android:text*-мeтoд *setText(int)* и т. д. Но бывают исключения. Так, для установки значения атрибута *anciroid:textColorHighlight* используется метод *setHighlightColor(int).* Как видите, название метода похоже на название атрибута, но не соответствует ему полностью. Все это говорит о том, что перед написанием Jаvа-кода желательно обратиться к документации и не полагаться только на одну интуицию. О Jаvа-коде мы поговорим позже, пока же рассмотрим типы разметки.


